<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.coreflow.shop.admin.product.AdProductMapper">

  <insert id="pro_insert" parameterType="com.coreflow.shop.common.dto.ProductDTO">
    INSERT INTO products (
      cate_code,
      pro_name,
      pro_price,
      pro_discount,
      pro_publisher,
      pro_summary,
      pro_up_folder,
      pro_img,
      pro_amount
    )
    VALUES (
      #{cate_code},
      #{pro_name},
      #{pro_price},
      #{pro_discount},
      #{pro_publisher},
      #{pro_summary},
      #{pro_up_folder},
      #{pro_img},
      #{pro_amount}
    )
  </insert>

  <!--
    수정: parameterType 제거.
    이유) 이 메서드는 Service/Mapper에서 @Param("cri"), @Param("period") 등
         여러 파라미터로 받으므로 parameterType을 지정하지 않는 편이 안전합니다.
         (지정하면 OGNL 경로 혼선의 원인이 됩니다)
    수정: LIMIT에서 pageStart/perPageNum → cri.pageStart/cri.perPageNum 로 변경.
  -->
  <select id="pro_list" resultType="map">
    SELECT
      pro_num,
      cate_code,
      pro_name,
      pro_price,
      pro_discount,
      pro_publisher,
      pro_summary,
      pro_up_folder,
      pro_img,
      pro_amount,
      pro_buy,
      pro_review,
      pro_date,
      pro_updatedate
    FROM products
    WHERE 1 = 1
    <include refid="search" />

    <!-- 수정: LIMIT의 파라미터 경로에 cri. 접두사 사용 -->
    LIMIT #{cri.pageStart}, #{cri.perPageNum}
  </select>

  <select id="getTotalCount" resultType="int">
    SELECT COUNT(*)
    FROM products
    WHERE 1 = 1
    <include refid="search" />
  </select>

  <!-- 공통 검색 조건 -->
  <!--
    이미 수정됨: cri.searchType / cri.keyword 로 접근하도록 정리
    추가 수정: 'np' 조건에서 AND ( ... OR ... ) 괄호로 우선순위 명확화
  -->
<!-- 공통 검색 조건 -->
<sql id="search">
  <!-- 검색어 -->
  <if test="cri.searchType != null and cri.searchType != ''">

    <if test="cri.searchType == 'n'.toString()">
      AND pro_name LIKE CONCAT('%', #{cri.keyword}, '%')
    </if>
    <if test="cri.searchType == 'c'.toString()">
      AND pro_num LIKE CONCAT('%', #{cri.keyword}, '%')
    </if>
    <if test="cri.searchType == 'p'.toString()">
      AND pro_publisher LIKE CONCAT('%', #{cri.keyword}, '%')
    </if>
    <if test="cri.searchType == 'np'.toString()">
      AND ( pro_name LIKE CONCAT('%', #{cri.keyword}, '%')
            OR pro_publisher LIKE CONCAT('%', #{cri.keyword}, '%') )
    </if>
  </if>

  <!-- 카테고리 -->
  <if test="cate_code != null and cate_code != ''">
    AND cate_code = #{cate_code}
  </if>

  <!-- 날짜(period 화이트리스트) : 오늘 검색이 ‘00:00~23:59:59’ 다 포함되게 -->
  <choose>
    <when test="period == 'pro_date'">
      <if test="start_date != null and start_date != '' and end_date != null and end_date != ''">
        AND pro_date BETWEEN CONCAT(#{start_date}, ' 00:00:00')
                        AND     CONCAT(#{end_date},   ' 23:59:59')
      </if>
    </when>
    <when test="period == 'pro_updatedate'">
      <if test="start_date != null and start_date != '' and end_date != null and end_date != ''">
        AND pro_updatedate BETWEEN CONCAT(#{start_date}, ' 00:00:00')
                              AND     CONCAT(#{end_date},   ' 23:59:59')
      </if>
    </when>
    <!-- 그 외 값이면 날짜필터 미적용 -->
  </choose>
</sql>


  <!-- 단건 상품 수정폼 -->
  <!--
    주의: Mapper 인터페이스에서 pro_edit_form(@Param("pro_num") Integer pro_num) 로
         이름 고정되어 있어야 #{pro_num}로 바인딩됩니다.
         (만약 @Param 미사용이라면 #{value} 또는 #{_parameter} 사용)
  -->
  <select id="pro_edit_form" resultType="com.coreflow.shop.common.dto.ProductDTO">
    SELECT
      pro_num,
      cate_code,
      pro_name,
      pro_price,
      pro_discount,
      pro_publisher,
      pro_summary,
      pro_up_folder,
      pro_img,
      pro_amount,
      pro_buy,
      pro_date,
      pro_updatedate
    FROM products
    WHERE pro_num = #{pro_num}
  </select>

  <!-- 상품수정(변경) -->
  <!--
    참고: PK(pro_num)를 SET으로 바꾸는 건 보통 권장하지 않습니다.
         현재 로직에 필요 없다면 pro_num=#{pro_num} 항목은 SET에서 제거 권장.
  -->
  <update id="pro_edit_modify" parameterType="com.coreflow.shop.common.dto.ProductDTO">
    UPDATE products
    SET
      pro_num        = #{pro_num},
      cate_code      = #{cate_code},
      pro_name       = #{pro_name},
      pro_price      = #{pro_price},
      pro_discount   = #{pro_discount},
      pro_publisher  = #{pro_publisher},
      pro_summary    = #{pro_summary},
      pro_up_folder  = #{pro_up_folder},
      pro_img        = #{pro_img},
      pro_amount     = #{pro_amount},
      pro_buy        = #{pro_buy},
      pro_updatedate = NOW()
    WHERE pro_num = #{pro_num}
  </update>

  <!-- 삭제 -->
  <!--
    주의: Mapper 인터페이스가 pro_delete(@Param("pro_num") Integer pro_num) 이어야
         #{pro_num}로 바인딩됩니다. (@Param 미지정이면 #{value} 사용)
  -->
  <delete id="pro_delete" parameterType="Integer">
    DELETE FROM products
    WHERE pro_num = #{pro_num}
  </delete>

  <!-- 배열로 상품번호 삭제 -->
  <!--
    수정: id="/pro_sel_delete_2" → id="pro_sel_delete_2" (슬래시 제거)
    수정: 잘못된 SQL("pro_numin in" 등) → 정식 IN 구문으로 교체
    수정: <foreach> 문법/속성 정정, 들여쓰기/가독성 개선
    주의: Mapper 인터페이스에서 pro_sel_delete_2(@Param("pro_num_arr") int[] pro_num_arr)
         로 선언되어 있어야 아래 collection 명칭이 일치합니다.
  -->
  <delete id="pro_sel_delete_2">
    DELETE FROM products
    WHERE pro_num IN
    <foreach collection="pro_num_arr" item="num" open="(" separator="," close=")">
      #{num}
    </foreach>
  </delete>

  <!-- 이름 + 다건(pro_num 배열) 조건 삭제 -->
  <!--
    수정: map 파라미터 사용 시 @Param("map")으로 받았다면
         키 접근은 #{map.pro_name}, collection="map.pro_num_arr" 로 해야 합니다.
    수정: 기존 SQL의 대상 컬럼/문법 오류(pro_name IN ...에 pro_num 배열을 바인딩하던 문제) 수정
         → pro_num IN (...) 으로 정정
  -->
  <delete id="pro_sel_delete_add_info">
    DELETE FROM products
    WHERE pro_name = #{map.pro_name}
      AND pro_num IN
      <foreach collection="map.pro_num_arr" item="num" open="(" separator="," close=")">
        #{num}
      </foreach>
  </delete>

</mapper>
